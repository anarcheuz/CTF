// This is a server for sorting strings. Protocol:
//  - you connect to the server
//  - you send requests and get responses
//  - the end
// A request or response looks like this: {uint32_t len}, {char data[len]}.
// The "data" portion contains comma-seperated texts. The server then
// sorts them and sends back sorted values in the same format as the request, but without
// a length prefix (because request and response have the same length anyway).

#include <pthread.h>
#include <stdlib.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <unistd.h>
#include <errno.h>
#include <stdint.h>
#include <string.h>

struct value {
  char *buf;
  size_t len;
};

int compare_values(const void *a_, const void *b_) {
  const struct value *a = a_;
  const struct value *b = b_;
  size_t lower_size = (a->len < b->len) ? a->len : b->len;
  int r = memcmp(a->buf, b->buf, lower_size);
  if (r != 0) return r;
  if (a->len == b->len) return 0;
  if (a->len < b->len) return -1;
  return 1;
}

int handle_packet(int s, char *buf, uint32_t len) {
  // 1000 values should be enough for anyone :D
  struct value values[1000];

  if (len == 0) return 0; // missing input

  // parse input into `values`
  char *p = buf;
  int i = 0; /* index in values; will be member count at the end */
  values[i] = (struct value){.buf = p, .len = 0};
  for (; p<buf+len; p++) {
    if (*p == ',') {
      i++;
      if (i == 1000) return 0; // too much data
      values[i] = (struct value){.buf = p+1, .len = 0};
    } else {
      values[i].len++;
    }
  }
  i++;
  fprintf(stderr, "got %d values\n", i);

  // sort input
  qsort(values, i, sizeof(values[0]), compare_values);

  // assemble response
  char *buf2 = malloc(len);
  p = buf2;
  for (int j = 0; j < i; j++) {
    if (j != 0) *p++ = ',';
    memcpy(p, values[j].buf, values[j].len);
    p += values[j].len;
  }

  // write response
  size_t written = 0;
  ssize_t r;
write_more:
  r = write(s, buf2+written, len-written);
  if (r < 0 && errno == EAGAIN) goto write_more;
  if (r <= 0) {
    free(buf2);
    return 0;
  }
  written += r;
  if (written < len) goto write_more;

  return 1;
}

// read [4 bytes: n], [n bytes: data]
// returns 0 for "end", 1 for "process more data"
int recv_packet(int s, uint32_t l, char *b, uint32_t done) {
  // read length. one byte at a time â€“ easier to handle partial reads that way.
  if (b == NULL && (l&0x80000000)) {
    uint8_t next_len_char;
    int r = read(s, &next_len_char, 1);
    if (r<0 && errno == EAGAIN) return recv_packet(s, l, b, done);
    if (r<=0) return 0;
    return recv_packet(s, (l<<8)|next_len_char, b, done);
  }

  if (b == NULL) {
    b = malloc(l);
  }
  if (b == NULL) perror("unable to allocate memory"), exit(1);

  if (l == done) {
    int r = handle_packet(s, b, l);
    free(b);
    return r;
  }

  int r = read(s, b+done, l-done);
  if ((r<0 && errno != EAGAIN) || r==0) return 0;
  return recv_packet(s, l, b, done+r);
}

void *handle_con(void *s_) {
  int s = (int)(intptr_t)s_;
  while (recv_packet(s, 0xffffffff, NULL, 0));
  close(s);
  return NULL;
}

int main(void) {
  int server_socket = 0;
  while (1) {
    int socket = accept(server_socket, NULL, NULL);
    if (socket < 0) perror("accept() failed"), exit(1);

    pthread_t thread_id;
    int r;
    pthread_attr_t attrs;
    if (pthread_attr_init(&attrs) || pthread_attr_setdetachstate(&attrs, PTHREAD_CREATE_DETACHED)) {
      perror("unable to prepare pthread attrs");
      exit(1);
    }
    if ((r=pthread_create(&thread_id, &attrs, handle_con, (void*)(intptr_t)socket))) {
      errno = r;
      perror("pthread_create failed");
      exit(1);
    }
  }
}
