// This service lets you start private instances of services and connect to them.

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <errno.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/un.h>
#include <signal.h>


#define COMMAND_LAUNCH_SERVICE 20
#define COMMAND_ACCESS_SERVICE 14

char* service_types[] = {
  "./profile_viewer",
  "./sorter"
};

/* this function is from the nacl library, I modified it a bit */
static int rb_fd = -1;
void randombytes(char *x,unsigned long long xlen)
{
  int i;

  if (rb_fd == -1) {
    rb_fd = open("/dev/urandom",O_RDONLY);
    if (rb_fd == -1) exit(1);
  }

  while (xlen > 0) {
    if (xlen < 1048576) i = xlen; else i = 1048576;

    i = read(rb_fd,x,i);
    if (i < 1) {
      exit(1);
    }

    x += i;
    xlen -= i;
  }
}

int atomic_write(int fd, char *buf, ssize_t len) {
  while (len > 0) {
    ssize_t res = write(fd, buf, len);
    if (res == 0 || (res == -1 && errno != EAGAIN)) return res;
    buf += res;
    len -= res;
  }
  return 1;
}

void handle(int s) {
  // Let's handle the socket like a normal terminal or so. Makes the code much
  // nicer. :)
  if (dup2(s, 0)==-1 || dup2(s, 1)==-1) exit(1);
  close(s);
  setbuf(stdin, NULL);
  setbuf(stdout, NULL);

  alarm(300);

  switch (getchar()) {
    case COMMAND_LAUNCH_SERVICE: {
      unsigned char service_type = (unsigned char) getchar();
      if (service_type >= sizeof(service_types)/sizeof(service_types[0])) {
        puts("Invalid service type.");
        return;
      }
      
      // Make a new random instance ID from the PID and, to prevent others
      // from guessing the ID, also 16 random characters.
      char service_id[64];
      randombytes(service_id, 16);
      for (int i=0; i<16; i++) service_id[i] = (service_id[i] & 0x0f) | 0x40;
      service_id[16] = '/';
      sprintf(service_id+17, "%llu", (unsigned long long)getpid());

      // Create an abstract unix domain socket for clients of the service.
      close(0); // this will let the domain socket take FD 0
      int ds = socket(AF_UNIX, SOCK_STREAM, 0);
      if (ds != 0) {
        if (ds < 0) {
          perror("socket() failed");
        } else {
          fputs("socket() didn't return 0 as expected\n", stderr);
        }
        return;
      }
      struct sockaddr_un address = { .sun_family = AF_UNIX };
      memcpy(address.sun_path, "\0mario-server-", 14);
      strcpy(address.sun_path+14, service_id);
      if (bind(0, (struct sockaddr *)&address, sizeof(sa_family_t)+1+strlen(address.sun_path+1))) {
        perror("abstract namespace bind failed");
        return;
      }
      if (listen(0, 4)) {
        perror("listen failed");
        return;
      }

      // Tell the client what the instance ID is, then disconnect. He can now
      // connect with COMMAND_ACCESS_SERVICE.
      puts(service_id);
      close(1);
      // Open /dev/null as stdout, we don't want that fd to be unallocated.
      if (open("/dev/null", O_WRONLY) != 1) {
        fputs("open() didn't return 1 as expected\n", stderr);
        return;
      }
      
      // launch the service, restricted to one minute lifetime
      // TODO TODO TODO reenable alarm(60); // OH GOD A BOMB DISARM THE TIMER
      execl(service_types[service_type], service_types[service_type], NULL);
      perror("execl failed");
    } break;
    case COMMAND_ACCESS_SERVICE: {
      struct sockaddr_un address = { .sun_family = AF_UNIX };
      memcpy(address.sun_path, "\0mario-server-", 14);
      if (fgets(address.sun_path+14, 64, stdin) == NULL) return;
      if (address.sun_path[strlen(address.sun_path+1)] == '\n') {
        address.sun_path[strlen(address.sun_path+1)] = '\0';
      }
      
      int ds = socket(AF_UNIX, SOCK_STREAM, 0);
      if (ds < 0) {
        perror("socket() failed");
        return;
      }
      if (connect(ds, (struct sockaddr *)&address, sizeof(sa_family_t)+1+strlen(address.sun_path+1))) {
        puts("invalid service ID - did you wait too long? services die after a while (grep for alarm)");
        return;
      }
      
      // Now we just shovel data around between the domain socket and the tcp socket. As soon as one of them
      // is closed for reading, we stop.
      fd_set rfds;
      while (1) {
        char buf[1024];
        FD_ZERO(&rfds);
        FD_SET(0, &rfds);
        FD_SET(ds, &rfds);
        if (select(ds+1, &rfds, NULL, NULL, NULL) < 0) {
          perror("select failed");
          return;
        }
        if (FD_ISSET(0, &rfds)) {
          ssize_t len = read(0, buf, 1024);
          if (len <= 0) return;
          if (atomic_write(ds, buf, len) != 1) {
            return;
          }
        }
        if (FD_ISSET(ds, &rfds)) {
          ssize_t len = read(ds, buf, 1024);
          if (len <= 0) return;
          if (atomic_write(1, buf, len) != 1) {
            return;
          }
        }
      }
    } break;
    default: {
      puts("Invalid command.");
    } break;
  }
}

int main(void) {
  signal(SIGCHLD, SIG_IGN);

  int s = socket(AF_INET, SOCK_STREAM, 0);
  if (s == -1) perror("unable to create server socket"), exit(1);
  
  int yes = 1;
  if (setsockopt(s, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(int)) == -1 ) {
    perror("setsockopt failed");
    return 1;
  }
  
  struct sockaddr_in bind_addr = {
    .sin_family = AF_INET,
    .sin_addr = (struct in_addr) { .s_addr = 0 },
    .sin_port = htons(1407)
  };
  if (bind(s, (struct sockaddr *)&bind_addr, sizeof(bind_addr))) perror("unable to bind socket"), exit(1);
  if (listen(s, 0x10)) perror("deaf"), exit(1);

  while (1) {
    int s_ = accept(s, NULL, NULL);
    if (s_ == -1) {
      perror("accept failed, is this bad?"); /* On Error Resume Next */
      continue;
    }
    pid_t child_pid = fork();
    if (child_pid == -1) {
      perror("can't fork! that's bad, I think.");
      close(s_);
      continue;
    }
    if (child_pid == 0) close(s), handle(s_), exit(0);
    close(s_);
  }
}
